{"version":3,"sources":["../src/index.ts","../../../utils/src/core/constants.ts","../../../utils/src/core/assign.ts","../../../utils/src/core/castValue.ts","../../../utils/src/core/getByStringDot.ts","../../../utils/src/core/getId.ts","../../../utils/src/core/getMarketingParameters.ts","../../../utils/src/core/invocations.ts","../../../utils/src/core/isSameType.ts","../../../utils/src/core/onLog.ts","../../../utils/src/core/throwError.ts","../../../utils/src/core/trim.ts","../../../utils/src/core/tryCatch.ts","../../../utils/src/core/useHooks.ts","../../../utils/src/core/validate.ts","../../../utils/src/web/getAttribute.ts","../../../utils/src/web/isVisible.ts","../../../utils/src/web/sessionStart.ts","../../../utils/src/web/storage.ts","../src/push.ts","../src/config.ts","../src/types/client.ts","../src/types/destination.ts"],"sourcesContent":["import type { WalkerOS } from '@elbwalker/types';\nimport type { NodeClient, NodeDestination } from './types';\nimport {\n  Const,\n  assign,\n  getId,\n  isSameType,\n  tryCatchAsync,\n} from '@elbwalker/utils';\nimport { pushToDestinations } from './push';\nimport { getConfig } from './config';\n\n// Types\nexport * from './types';\n\nexport function createNodeClient(customConfig?: NodeClient.PartialConfig) {\n  const instance = nodeClient(customConfig);\n  const elb = instance.push;\n\n  return { elb, instance };\n}\n\nexport function nodeClient(\n  customConfig: NodeClient.PartialConfig = {},\n): NodeClient.Function {\n  const client = '2.0.0';\n  const config = getConfig(customConfig, {\n    client,\n    globalsStatic: customConfig.globals, // Initial globals are static values\n  });\n\n  const push: NodeClient.Push = async (...args) => {\n    const defaultResult: NodeClient.PushResult = {\n      status: { ok: false },\n      successful: [],\n      queued: [],\n      failed: [],\n    };\n\n    return await tryCatchAsync(pushFn, (error) => {\n      // Call custom error handling\n      if (config.onError) config.onError(error, instance);\n\n      defaultResult.status.error = String(error);\n      return defaultResult;\n    })(instance, ...args);\n  };\n\n  const instance: NodeClient.Function = {\n    config,\n    push,\n  };\n\n  // That's when the party starts\n  run(instance); // @TODO check for allowed?\n\n  return instance;\n}\n\nasync function addDestination(\n  instance: NodeClient.Function,\n  data: unknown = {},\n  options: unknown = {},\n) {\n  if (!isSameType(data, {} as NodeDestination.Function)) return;\n  if (!isSameType(options, {} as NodeDestination.Config)) return;\n\n  // Prefere explicit given config over default config\n  const config = options || data.config || { init: false };\n\n  const destination: NodeDestination.Function = {\n    init: data.init,\n    push: data.push,\n    config,\n    type: data.type,\n  };\n\n  let id = config.id; // Use given id\n  if (!id) {\n    // Generate a new id if none was given\n    do {\n      id = getId(4);\n    } while (instance.config.destinations[id]);\n  }\n\n  instance.config.destinations[id] = destination;\n\n  // Process previous events if not disabled\n  if (config.queue !== false) destination.queue = [...instance.config.queue];\n  return await pushToDestinations(instance, undefined, { [id]: destination });\n}\n\nconst pushFn: NodeClient.PrependInstance<NodeClient.Push> = async (\n  instance,\n  nameOrEvent,\n  data,\n  options,\n) => {\n  const result: NodeClient.PushResult = {\n    status: { ok: false },\n    successful: [],\n    queued: [],\n    failed: [],\n  };\n\n  // Parameter handling\n  if (isSameType(nameOrEvent, '' as string))\n    nameOrEvent = { event: nameOrEvent };\n\n  // Create the event\n  const { event, action } = getEventOrAction(instance, nameOrEvent);\n\n  // Walker command\n  if (action) {\n    const command = await handleCommand(instance, action, data, options);\n    if (command.result) {\n      if (isSameType(command.result, {} as NodeDestination.PushResult)) {\n        if (command.result.successful)\n          result.successful = command.result.successful;\n        if (command.result.queued) result.queued = command.result.queued;\n        if (command.result.failed) result.failed = command.result.failed;\n      }\n    }\n\n    result.command = command.command;\n    result.status.ok = true;\n  }\n\n  // Regular event\n  if (event) {\n    // Add event to internal queue\n    instance.config.queue.push(event);\n\n    const { successful, queued, failed } = await pushToDestinations(\n      instance,\n      event,\n    );\n\n    result.event = event;\n    result.status.ok = failed.length === 0;\n    result.successful = successful;\n    result.queued = queued;\n    result.failed = failed;\n  }\n\n  return result;\n};\n\nfunction getEventOrAction(\n  instance: NodeClient.Function,\n  props: Partial<WalkerOS.Event> = {},\n): { event?: WalkerOS.Event; action?: string } {\n  if (!props.event) throw new Error('Event name is required');\n\n  const [entity, action] = props.event.split(' ');\n  if (!entity || !action) throw new Error('Event name is invalid');\n\n  if (entity === Const.Commands.Walker) return { action };\n\n  const config = instance.config;\n\n  ++config.count;\n\n  const timestamp = props.timestamp || Date.now();\n  const timing =\n    props.timing ||\n    Math.round((timestamp - (props.timing || config.timing)) / 10) / 100;\n  const group = props.group || config.group;\n  const count = props.count || config.count;\n  const source = props.source || config.source;\n  if (props.source) {\n    if (props.source.id) source.id = props.source.id;\n    if (props.source.previous_id) source.previous_id = props.source.previous_id;\n  }\n\n  const event = {\n    event: props.event,\n    data: props.data || {},\n    context: props.context || {},\n    custom: props.custom || {},\n    globals: props.globals || config.globals,\n    user: props.user || config.user,\n    nested: props.nested || [],\n    consent: props.consent || config.consent,\n    trigger: props.trigger || '',\n    entity,\n    action,\n    timestamp,\n    timing,\n    group,\n    count,\n    id: `${timestamp}-${group}-${count}`,\n    version: {\n      client: config.client,\n      tagging: config.tagging,\n    },\n    source,\n  };\n\n  return { event };\n}\n\nasync function handleCommand(\n  instance: NodeClient.Function,\n  action: string,\n  data?: NodeClient.PushData,\n  options?: NodeClient.PushOptions,\n): Promise<{ command: NodeClient.Command; result?: NodeClient.PushData }> {\n  let command: NodeClient.Command = { name: action, data };\n  let result: NodeClient.PushData | undefined;\n\n  switch (action) {\n    case Const.Commands.Config:\n      command.data = setConfig(instance, data) || {};\n      break;\n    case Const.Commands.Consent:\n      result = await setConsent(instance, data);\n      break;\n    case Const.Commands.Destination:\n      result = await addDestination(instance, data, options);\n      break;\n    case Const.Commands.Run:\n      result = run(instance, data);\n      break;\n    case Const.Commands.User:\n      command.data = setUser(instance, data);\n      break;\n  }\n\n  return { command, result };\n}\n\nfunction setConfig(instance: NodeClient.Function, data: unknown = {}) {\n  if (!isSameType(data, {} as WalkerOS.Config)) return;\n  //@TODO strict type checking\n\n  instance.config = getConfig(data, instance.config);\n  return instance.config;\n}\n\nasync function setConsent(instance: NodeClient.Function, data: unknown = {}) {\n  if (!isSameType(data, {} as WalkerOS.Consent)) return;\n\n  let runQueue = false;\n  Object.entries(data).forEach(([consent, granted]) => {\n    const state = !!granted;\n\n    instance.config.consent[consent] = state;\n\n    // Only run queue if state was set to true\n    runQueue = runQueue || state;\n  });\n\n  if (runQueue) return await pushToDestinations(instance);\n}\n\nfunction setUser(instance: NodeClient.Function, data: unknown = {}) {\n  if (!isSameType(data, {} as WalkerOS.User)) return;\n\n  const user: WalkerOS.User = {};\n\n  if ('id' in data) user.id = data.id;\n  if ('device' in data) user.device = data.device;\n  if ('session' in data) user.session = data.session;\n\n  instance.config.user = user;\n  return user;\n}\n\nfunction run(instance: NodeClient.Function, data: unknown = {}) {\n  if (!isSameType(data, {} as WalkerOS.Properties)) return;\n\n  instance.config = assign(instance.config, {\n    allowed: true, // Free the client\n    count: 0, // Reset the run counter\n    globals: assign(data, instance.config.globalsStatic),\n    timing: Date.now(), // Set the timing offset\n    group: getId(), // Generate a new group id for each run\n  });\n\n  // Reset the queue for each run without merging\n  instance.config.queue = [];\n\n  // Reset all destination queues\n  Object.values(instance.config.destinations).forEach((destination) => {\n    destination.queue = [];\n  });\n\n  return instance.config;\n}\n\nexport default createNodeClient;\n","import type { Utils as TUtils, WalkerOS } from '@elbwalker/types';\n\nconst Commands: { [key: string]: WalkerOS.Commands } = {\n  Action: 'action',\n  Config: 'config',\n  Consent: 'consent',\n  Context: 'context',\n  Destination: 'destination',\n  Elb: 'elb',\n  Globals: 'globals',\n  Hook: 'hook',\n  Init: 'init',\n  Link: 'link',\n  Prefix: 'data-elb',\n  Run: 'run',\n  User: 'user',\n  Walker: 'walker',\n} as const;\n\nconst UtilsStorage: { [key: string]: TUtils.StorageType } = {\n  Cookie: 'cookie',\n  Local: 'local',\n  Session: 'session',\n} as const;\n\nconst Utils = {\n  Storage: UtilsStorage,\n};\n\nexport const Const = {\n  Commands,\n  Utils,\n};\n\nexport default Const;\n","export function assign<T>(target: T, source: Object = {}): T {\n  // Check for array properties to merge them before overriding\n  Object.entries(source).forEach(([key, sourceProp]) => {\n    const targetProp = target[key as keyof typeof target];\n\n    // Only merge arrays\n    if (Array.isArray(targetProp) && Array.isArray(sourceProp)) {\n      source[key as keyof typeof source] = sourceProp.reduce(\n        (acc, item) => {\n          // Remove duplicates\n          return acc.includes(item) ? acc : [...acc, item];\n        },\n        [...targetProp],\n      );\n    }\n  });\n\n  return { ...target, ...source };\n}\n","import { WalkerOS } from '@elbwalker/types';\n\nexport function castValue(value: unknown): WalkerOS.PropertyType {\n  if (value === 'true') return true;\n  if (value === 'false') return false;\n\n  const number = Number(value); // Converts \"\" to 0\n  if (value == number && value !== '') return number;\n\n  return String(value);\n}\n","export function getByStringDot(\n  event: unknown,\n  key: string,\n  i: unknown = 0,\n): unknown {\n  // String dot notation for object (\"data.id\" -> { data: { id: 1 } })\n  const value = key.split('.').reduce((obj, key) => {\n    // Update the wildcard to the given index\n    if (key == '*') key = String(i);\n\n    if (obj instanceof Object) return obj[key as keyof typeof obj];\n\n    return;\n  }, event);\n\n  return value;\n}\n","export function getId(length = 6): string {\n  for (var str = '', l = 36; str.length < length; )\n    str += ((Math.random() * l) | 0).toString(l);\n  return str;\n}\n","import { Utils, WalkerOS } from '@elbwalker/types';\n\nexport function getMarketingParameters(\n  url: URL,\n  custom: Utils.MarketingParameters = {},\n): WalkerOS.Properties {\n  const data: WalkerOS.Properties = {};\n  const parameters = Object.assign(\n    {\n      utm_campaign: 'campaign',\n      utm_content: 'content',\n      dclid: 'clickId',\n      fbclid: 'clickId',\n      gclid: 'clickId',\n      utm_medium: 'medium',\n      msclkid: 'clickId',\n      utm_source: 'source',\n      utm_term: 'term',\n    },\n    custom,\n  );\n\n  Object.entries(parameters).forEach(([param, name]) => {\n    const value = url.searchParams.get(param);\n    if (value) data[name] = value;\n  });\n\n  return data;\n}\n","export function debounce<P extends unknown[], R>(\n  fn: (...args: P) => R,\n  wait = 1000,\n) {\n  let timer: number | NodeJS.Timeout;\n\n  return (...args: P): Promise<R> => {\n    // abort previous invocation\n    clearTimeout(timer);\n\n    // Return value as promise\n    return new Promise((resolve) => {\n      // Schedule execution\n      timer = setTimeout(() => {\n        // Call the function\n        resolve(fn(...args));\n      }, wait);\n    });\n  };\n}\n\ntype Timeout = ReturnType<typeof setTimeout>;\nexport function throttle<P extends unknown[], R>(\n  fn: (...args: P) => R | undefined,\n  delay = 1000,\n): (...args: P) => R | undefined {\n  let isBlocked: Timeout | null = null;\n\n  return function (...args: P): R | undefined {\n    // Skip since function is still blocked by previous call\n    if (isBlocked !== null) return;\n\n    // Set a blocking timeout\n    isBlocked = setTimeout(() => {\n      // Unblock function\n      isBlocked = null;\n    }, delay) as Timeout;\n\n    // Call the function\n    return fn(...args);\n  };\n}\n","export function isSameType<T>(\n  variable: unknown,\n  type: T,\n): variable is typeof type {\n  return typeof variable === typeof type;\n}\n","export function onLog(message: unknown, verbose = false): void {\n  if (verbose) console.dir(message, { depth: 4 });\n}\n","export function throwError(error: unknown): never {\n  throw new Error(String(error));\n}\n","export function trim(str: string): string {\n  // Remove quotes and whitespaces\n  return str ? str.trim().replace(/^'|'$/g, '').trim() : '';\n}\n","// Use function overload to support different return type depending on onError\n// Types\nexport function tryCatch<P extends unknown[], R, S>(\n  fn: (...args: P) => R | undefined,\n  onError: (err: unknown) => S,\n): (...args: P) => R | S;\nexport function tryCatch<P extends unknown[], R>(\n  fn: (...args: P) => R | undefined,\n): (...args: P) => R | undefined;\n// Implementation\nexport function tryCatch<P extends unknown[], R, S>(\n  fn: (...args: P) => R | undefined,\n  onError?: (err: unknown) => S,\n): (...args: P) => R | S | undefined {\n  return function (...args: P): R | S | undefined {\n    try {\n      return fn(...args);\n    } catch (err) {\n      if (!onError) return;\n      return onError(err);\n    }\n  };\n}\n\n// Use function overload to support different return type depending on onError\n// Types\nexport function tryCatchAsync<P extends unknown[], R, S>(\n  fn: (...args: P) => R,\n  onError: (err: unknown) => S,\n): (...args: P) => Promise<R | S>;\nexport function tryCatchAsync<P extends unknown[], R>(\n  fn: (...args: P) => R,\n): (...args: P) => Promise<R | undefined>;\n// Implementation\nexport function tryCatchAsync<P extends unknown[], R, S>(\n  fn: (...args: P) => R,\n  onError?: (err: unknown) => S,\n): (...args: P) => Promise<R | S | undefined> {\n  return async function (...args: P): Promise<R | S | undefined> {\n    try {\n      return await fn(...args);\n    } catch (err) {\n      if (!onError) return;\n      return await onError(err);\n    }\n  };\n}\n","import { Hooks } from '@elbwalker/types';\n\nexport function useHooks<P extends any[], R>(\n  fn: (...args: P) => R,\n  name: string,\n  hooks: Hooks.Functions,\n): (...args: P) => R {\n  return function (...args: P): R {\n    let result: R;\n    const preHook = ('pre' + name) as keyof Hooks.Functions;\n    const postHook = ('post' + name) as keyof Hooks.Functions;\n    const preHookFn = hooks[preHook] as unknown as Hooks.HookFn<typeof fn>;\n    const postHookFn = hooks[postHook] as unknown as Hooks.HookFn<typeof fn>;\n\n    if (preHookFn) {\n      // Call the original function within the preHook\n      result = preHookFn({ fn }, ...args);\n    } else {\n      // Regular function call\n      result = fn(...args);\n    }\n\n    if (postHookFn) {\n      // Call the post-hook function with fn, result, and the original args\n      result = postHookFn({ fn, result }, ...args);\n    }\n\n    return result;\n  };\n}\n","import { Schema, WalkerOS } from '@elbwalker/types';\nimport { throwError } from './throwError';\nimport { isSameType } from './isSameType';\nimport { tryCatch } from './tryCatch';\n\nexport function validateEvent(\n  obj: unknown,\n  customContracts: Schema.Contracts = [],\n): WalkerOS.Event | never {\n  if (!isSameType(obj, {} as WalkerOS.AnyObject)) throwError('Invalid object');\n\n  let event: string;\n  let entity: string;\n  let action: string;\n\n  // Check if event.event is available and it's a string\n  if (isSameType(obj.event, '')) {\n    event = obj.event;\n    [entity, action] = event.split(' ');\n    if (!entity || !action) throwError('Invalid event name');\n  } else if (isSameType(obj.entity, '') && isSameType(obj.action, '')) {\n    entity = obj.entity;\n    action = obj.action;\n    event = `${entity} ${action}`;\n  } else {\n    throwError('Missing or invalid event, entity, or action');\n  }\n\n  const basicContract: Schema.Contract = {\n    '*': {\n      '*': {\n        event: { maxLength: 255 }, // @TODO as general rule?\n        user: { allowedKeys: ['id', 'device', 'session'] },\n        consent: { allowedValues: [true, false] },\n        timestamp: { min: 0 },\n        timing: { min: 0 },\n        count: { min: 0 },\n        version: { allowedKeys: ['client', 'tagging'] },\n        source: { allowedKeys: ['type', 'id', 'previous_id'] },\n      },\n    },\n  };\n\n  const basicEvent: WalkerOS.Event = {\n    event,\n    data: {},\n    context: {},\n    custom: {},\n    globals: {},\n    user: {},\n    nested: [],\n    consent: {},\n    id: '',\n    trigger: '',\n    entity,\n    action,\n    timestamp: 0,\n    timing: 0,\n    group: '',\n    count: 0,\n    version: { client: '', tagging: 0 },\n    source: { type: '', id: '', previous_id: '' },\n  };\n\n  // Collect all relevant schemas for the event\n  const schemas = [basicContract]\n    .concat(customContracts)\n    .reduce((acc, contract) => {\n      return ['*', entity].reduce((entityAcc, e) => {\n        return ['*', action].reduce((actionAcc, a) => {\n          const schema = contract[e]?.[a];\n          return schema ? actionAcc.concat([schema]) : actionAcc;\n        }, entityAcc);\n      }, acc);\n    }, [] as Schema.Properties[]);\n\n  const result = schemas.reduce(\n    (acc, schema) => {\n      // Get all required properties\n      const requiredKeys = Object.keys(schema).filter((key) => {\n        const property = schema[key];\n        return property?.required === true;\n      });\n\n      // Validate both, ingested and required properties but only once\n      return [...Object.keys(obj), ...requiredKeys].reduce((acc, key) => {\n        const propertySchema = schema[key];\n        let value = obj[key];\n\n        if (propertySchema) {\n          // Update the value\n          value = tryCatch(validateProperty, (err) => {\n            throwError(String(err));\n          })(acc, key, value, propertySchema);\n        }\n\n        // Same type check\n        if (isSameType(value, acc[key])) acc[key] = value;\n\n        return acc;\n      }, acc);\n    },\n    // Not that beautiful but it works, narrowing down the type is tricky here\n    // it's important that basicEvent is defined as an WalkerOS.Event\n    basicEvent as unknown as WalkerOS.AnyObject,\n  ) as unknown as WalkerOS.Event;\n\n  // @TODO Final check for result.event === event.entity + ' ' + event.action\n\n  return result;\n}\n\nexport function validateProperty(\n  obj: WalkerOS.AnyObject,\n  key: string,\n  value: unknown,\n  schema: Schema.Property,\n): WalkerOS.Property | never {\n  // @TODO unknown to WalkerOS.Property\n\n  // Note regarding potentially malicious values\n  // Initial collection doesn't manipulate data\n  // Prefer context-specific checks in the destinations\n\n  // Custom validate function can change the value\n  if (schema.validate)\n    value = tryCatch(schema.validate, (err) => {\n      throwError(String(err));\n    })(value, key, obj);\n\n  if (schema.required && value === undefined)\n    throwError('Missing required property');\n\n  // Strings\n  if (isSameType(value, '' as string)) {\n    if (schema.maxLength && value.length > schema.maxLength) {\n      if (schema.strict) throwError('Value exceeds maxLength');\n      value = value.substring(0, schema.maxLength);\n    }\n  }\n\n  // Numbers\n  else if (isSameType(value, 1 as number)) {\n    if (isSameType(schema.min, 1) && value < schema.min) {\n      if (schema.strict) throwError('Value below min');\n      value = schema.min;\n    } else if (isSameType(schema.max, 1) && value > schema.max) {\n      if (schema.strict) throwError('Value exceeds max');\n      value = schema.max;\n    }\n  }\n\n  // @TODO boolean\n\n  // Objects\n  else if (isSameType(value, {} as WalkerOS.AnyObject)) {\n    if (schema.schema) {\n      const nestedSchema = schema.schema;\n\n      // @TODO handle return to update value as non unknown\n      // @TODO bug with multiple rules in property schema\n      Object.keys(nestedSchema).reduce((acc, key) => {\n        const propertySchema = nestedSchema[key];\n        let value = acc[key];\n\n        if (propertySchema) {\n          // Type check\n          if (propertySchema.type && typeof value !== propertySchema.type)\n            throwError(`Type doesn't match (${key})`);\n\n          // Update the value\n          value = tryCatch(validateProperty, (err) => {\n            throwError(String(err));\n          })(acc, key, value, propertySchema);\n        }\n\n        return value as WalkerOS.AnyObject;\n      }, value);\n    }\n\n    for (const [objKey, objValue] of Object.entries(value)) {\n      // Check for allowed keys if applicable\n      if (schema.allowedKeys && !schema.allowedKeys.includes(objKey)) {\n        if (schema.strict) throwError('Key not allowed');\n\n        delete value[objKey];\n      }\n    }\n  }\n\n  return value as WalkerOS.Property;\n}\n","// @TODO add trim\nexport function getAttribute(element: Element, name: string): string {\n  return element.getAttribute(name) || '';\n}\n","export function isVisible(element: HTMLElement): boolean {\n  // Check for hiding styles\n  const style = getComputedStyle(element);\n  if (style.display === 'none') return false;\n  if (style.visibility !== 'visible') return false;\n  if (style.opacity && Number(style.opacity) < 0.1) return false;\n\n  // Window positions\n  let pointContainer;\n  const windowHeight = window.innerHeight; // Height of the viewport\n\n  // Element positions\n  const elemRectRel = element.getBoundingClientRect(); // Get the elements relative to the viewport\n  const elementHeight = elemRectRel.height; // Height of the element\n  const elementTopRel = elemRectRel.y; // Relative distance from window top to element top\n  const elementBottomRel = elementTopRel + elementHeight; // Relative distance from window to to element bottom\n  const elemCenterRel = {\n    // Relative position on viewport of the elements center\n    x: elemRectRel.x + element.offsetWidth / 2,\n    y: elemRectRel.y + element.offsetHeight / 2,\n  };\n\n  // Differentiate between small and large elements\n  if (elementHeight <= windowHeight) {\n    // Smaller than the viewport\n\n    // Must have a width and height\n    if (\n      element.offsetWidth + elemRectRel.width === 0 ||\n      element.offsetHeight + elemRectRel.height === 0\n    )\n      return false;\n\n    if (elemCenterRel.x < 0) return false;\n    if (\n      elemCenterRel.x >\n      (document.documentElement.clientWidth || window.innerWidth)\n    )\n      return false;\n    if (elemCenterRel.y < 0) return false;\n    if (\n      elemCenterRel.y >\n      (document.documentElement.clientHeight || window.innerHeight)\n    )\n      return false;\n\n    // Select the element that is at the center of the target\n    pointContainer = document.elementFromPoint(\n      elemCenterRel.x,\n      elemCenterRel.y,\n    );\n  } else {\n    // Bigger than the viewport\n\n    // that are considered visible if they fill half of the screen\n    const viewportCenter = windowHeight / 2;\n\n    // Check if upper part is above the viewports center\n    if (elementTopRel < 0 && elementBottomRel < viewportCenter) return false;\n\n    // Check if lower part is below the viewports center\n    if (elementBottomRel > windowHeight && elementTopRel > viewportCenter)\n      return false;\n\n    // Select the element that is in the middle of the screen\n    pointContainer = document.elementFromPoint(\n      elemCenterRel.x,\n      windowHeight / 2,\n    );\n  }\n\n  // Check for potential overlays\n  if (pointContainer) {\n    do {\n      if (pointContainer === element) return true; // should be visible\n    } while ((pointContainer = pointContainer.parentElement));\n  }\n\n  return false;\n}\n","import { Utils, WalkerOS } from '@elbwalker/types';\nimport { getId, getMarketingParameters } from '..';\n\nexport function sessionStart(\n  config: Utils.SessionStart = {},\n): WalkerOS.Properties | false {\n  // Force a new session or start checking if it's a regular new one\n  let isNew = config.isNew || false;\n\n  // Entry type\n  if (!isNew) {\n    // Only focus on linked or direct navigation types\n    // and ignore reloads and all others\n    const [perf] = performance.getEntriesByType(\n      'navigation',\n    ) as PerformanceNavigationTiming[];\n    if (perf.type !== 'navigate') return false;\n  }\n\n  const url = new URL(config.url || window.location.href);\n  const ref = config.referrer || document.referrer;\n  const referrer = ref && new URL(ref).hostname;\n  const session: WalkerOS.Properties = {};\n\n  // Marketing\n  const marketing = getMarketingParameters(url, config.parameters);\n  if (Object.keys(marketing).length) {\n    // Check for marketing parameters like UTM and add existing\n    session.marketing = true; // Flag as a marketing session\n    isNew = true;\n  }\n\n  // Referrer\n  if (!isNew) {\n    // Small chance of multiple unintendet events for same users\n    // https://en.wikipedia.org/wiki/HTTP_referer#Referrer_hiding\n    // Use domains: [''] to disable direct or hidden referrer\n\n    const domains = config.domains || [];\n    domains.push(url.hostname);\n    isNew = !domains.includes(referrer);\n  }\n\n  // No new session\n  if (!isNew) return false;\n\n  if (referrer) session.referrer = referrer;\n  Object.assign(\n    session,\n    {\n      id: session.id || getId(12),\n    },\n    marketing,\n    config.data,\n  );\n\n  // It's a new session, moin\n  return session;\n}\n","import { Utils, WalkerOS } from '@elbwalker/types';\nimport { Const, castValue } from '..';\n\nexport function storageDelete(\n  key: string,\n  storage: Utils.StorageType = Const.Utils.Storage.Session,\n) {\n  switch (storage) {\n    case Const.Utils.Storage.Cookie:\n      storageWrite(key, '', 0, storage);\n      break;\n    case Const.Utils.Storage.Local:\n      window.localStorage.removeItem(key);\n      break;\n    case Const.Utils.Storage.Session:\n      window.sessionStorage.removeItem(key);\n      break;\n  }\n}\n\nexport function storageRead(\n  key: string,\n  storage: Utils.StorageType = Const.Utils.Storage.Session,\n): WalkerOS.PropertyType {\n  // Helper function for local and session storage to support expiration\n  function parseItem(string: string | null): Utils.StorageValue {\n    try {\n      return JSON.parse(string || '');\n    } catch (err) {\n      let e = 1,\n        v = '';\n\n      // Remove expiration date\n      if (string) {\n        e = 0;\n        v = string;\n      }\n\n      return { e, v };\n    }\n  }\n  let value, item;\n\n  switch (storage) {\n    case Const.Utils.Storage.Cookie:\n      value = decodeURIComponent(\n        document.cookie\n          .split('; ')\n          .find((row) => row.startsWith(key + '='))\n          ?.split('=')[1] || '',\n      );\n      break;\n    case Const.Utils.Storage.Local:\n      item = parseItem(window.localStorage.getItem(key));\n      break;\n    case Const.Utils.Storage.Session:\n      item = parseItem(window.sessionStorage.getItem(key));\n      break;\n  }\n\n  // Check if item is expired\n  if (item) {\n    value = item.v;\n\n    if (item.e != 0 && item.e < Date.now()) {\n      storageDelete(key, storage); // Remove item\n      value = ''; // Conceal the outdated value\n    }\n  }\n\n  return castValue(value || '');\n}\n\nexport function storageWrite(\n  key: string,\n  value: WalkerOS.PropertyType,\n  maxAgeInMinutes = 30,\n  storage: Utils.StorageType = Const.Utils.Storage.Session,\n  domain?: string,\n): WalkerOS.PropertyType {\n  const e = Date.now() + 1000 * 60 * maxAgeInMinutes;\n  const item: Utils.StorageValue = { e, v: String(value) };\n  const stringifiedItem = JSON.stringify(item);\n\n  switch (storage) {\n    case Const.Utils.Storage.Cookie:\n      let cookie = `${key}=${encodeURIComponent(value)}; max-age=${\n        maxAgeInMinutes * 60\n      }; path=/; SameSite=Lax; secure`;\n\n      if (domain) cookie += '; domain=' + domain;\n\n      document.cookie = cookie;\n      break;\n    case Const.Utils.Storage.Local:\n      window.localStorage.setItem(key, stringifiedItem);\n      break;\n    case Const.Utils.Storage.Session:\n      window.sessionStorage.setItem(key, stringifiedItem);\n      break;\n  }\n\n  return storageRead(key, storage);\n}\n","import { Destination, WalkerOS } from '@elbwalker/types';\nimport { NodeClient, NodeDestination } from './types';\nimport { assign, isSameType, tryCatchAsync } from '@elbwalker/utils';\n\nexport function allowedToPush(\n  instance: NodeClient.Function,\n  destination: NodeDestination.Function,\n): boolean {\n  // Default without consent handling\n  let granted = true;\n\n  // Check for consent\n  const destinationConsent = destination.config.consent;\n\n  if (destinationConsent) {\n    // Let's be strict here\n    granted = false;\n\n    // Set the current consent states\n    const consentStates = instance.config.consent;\n\n    // Search for a required and granted consent\n    Object.keys(destinationConsent).forEach((consent) => {\n      if (consentStates[consent]) granted = true;\n    });\n  }\n\n  return granted;\n}\n\nexport async function pushToDestinations(\n  instance: NodeClient.Function,\n  event?: WalkerOS.Event,\n  destination?: NodeClient.Destinations,\n): Promise<NodeDestination.PushResult> {\n  // Push to all destinations if no destination was given\n  const destinations = destination || instance.config.destinations;\n  const config = instance.config;\n  const results: Array<{\n    id: string;\n    destination: NodeDestination.Function;\n    skipped?: boolean;\n    queue?: WalkerOS.Events;\n    error?: unknown;\n  }> = await Promise.all(\n    // Process all destinations in parallel\n    Object.entries(destinations).map(async ([id, destination]) => {\n      let error: unknown;\n\n      // Setup queue of events to be processed\n      const queue = ([] as Destination.Queue).concat(destination.queue || []);\n      destination.queue = []; // Reset original queue while processing\n\n      if (event)\n        // Add event to queue\n        queue.push(event);\n\n      if (!queue.length)\n        // Nothing to do here\n        return { id, destination, skipped: true };\n\n      // Always check for required consent states before pushing\n      if (!allowedToPush(instance, destination))\n        // Not allowed to continue\n        return { id, destination, queue };\n\n      // Update previous values with the current state\n      let events: NodeDestination.PushEvents = queue.map((event) => {\n        // @TODO check if this is correct, as a client might keeps running as a thread\n        event.consent = assign(config.consent, event.consent);\n        event.globals = assign(config.globals, event.globals);\n        event.user = assign(config.user, event.user);\n        return { event }; // @TODO mapping\n      });\n\n      // Destination initialization\n      // Check if the destination was initialized properly or try to do so\n      if (destination.init && !destination.config.init) {\n        const init =\n          (await tryCatchAsync(destination.init, (error) => {\n            // Call custom error handling\n            if (config.onError) config.onError(error, instance);\n          })(destination.config)) || false;\n\n        if (isSameType(init, {} as NodeDestination.Config)) {\n          destination.config = init;\n        } else {\n          destination.config.init = init;\n        }\n\n        // don't push if init is false\n        if (!init) return { id, destination, queue };\n      }\n\n      const result =\n        (await tryCatchAsync(destination.push, (error) => {\n          // Call custom error handling\n          if (config.onError) config.onError(error, instance);\n\n          // Default error handling for failing destinations\n          return { error, queue: undefined };\n        })(events, destination.config)) || {}; // everything is fine\n\n      error = result.error; // Captured error from destination\n\n      return { id, destination, queue: [], error };\n    }),\n  );\n\n  const successful: NodeDestination.PushSuccess = [];\n  const queued: NodeDestination.PushSuccess = [];\n  const failed: NodeDestination.PushFailure = [];\n\n  for (const result of results) {\n    if (result.skipped) continue;\n\n    const id = result.id;\n    const destination = result.destination;\n\n    if (result.error) {\n      failed.push({\n        id,\n        destination,\n        error: String(result.error),\n      });\n    } else if (result.queue && result.queue.length) {\n      // Merge queue with existing queue\n      destination.queue = assign(destination.queue, result.queue);\n      queued.push({ id, destination });\n    } else {\n      successful.push({ id, destination });\n    }\n  }\n\n  // @TODO add status check here\n  return { successful, queued, failed };\n}\n","import { assign, onLog } from '@elbwalker/utils';\nimport { NodeClient } from './types';\n\nexport function getConfig(\n  values: NodeClient.PartialConfig = {},\n  current: NodeClient.PartialConfig = {},\n): NodeClient.Config {\n  const globalsStatic = current.globalsStatic || {};\n  const defaultConfig: NodeClient.Config = {\n    allowed: false, // Wait for explicit run command to start\n    client: '0.0.0', // Client version\n    consent: {}, // Handle the consent states\n    custom: {}, // Custom state support\n    count: 0, // Event counter for each run\n    destinations: {}, // Destination list\n    globals: {}, // To be overwritten\n    globalsStatic, // Basic values from initial config\n    group: '', // Random id to group events of a run\n    hooks: {}, // Manage the hook functions\n    queue: [], // Temporary event queue for all events of a run\n    round: 0, // The first round is a special one due to state changes\n    timing: 0, // Offset counter to calculate timing property\n    user: {}, // Handles the user ids\n    tagging: 0, // Helpful to differentiate the clients used setup version\n    source: {\n      type: 'node',\n      id: '',\n      previous_id: '',\n    },\n    verbose: false, // Disable verbose logging\n  };\n\n  const config = {\n    ...defaultConfig,\n    ...current,\n    ...values,\n  };\n\n  const globals = assign(\n    globalsStatic,\n    assign(current.globals || {}, values.globals || {}),\n  );\n\n  // Log with default verbose level\n  function log(message: string, verbose?: boolean) {\n    onLog({ message }, verbose || config.verbose);\n  }\n\n  // Value hierarchy: values > current > default\n  return {\n    ...config,\n    globals,\n    globalsStatic,\n    onLog: log,\n  };\n}\n","import type { WalkerOS, Schema, Handler } from '@elbwalker/types';\nimport type * as NodeDestination from './destination';\n\nexport interface Function {\n  config: Config;\n  push: Push;\n  setup?: Setup; // @TODO make this required\n}\n\nexport interface AddDestination {\n  (id: string, destination: NodeDestination.Function<any, any>): void;\n}\n\nexport interface Push {\n  (\n    nameOrEvent: string | WalkerOS.PartialEvent,\n    data?: PushData,\n    options?: PushOptions,\n  ): Promise<PushResult>;\n}\n\nexport interface Setup {\n  (config: Config): Promise<SetupResult>;\n}\n\nexport type PushData =\n  | WalkerOS.PushData\n  | NodeDestination.Function<any, any>\n  | NodeDestination.PushResult;\n\nexport type PushOptions = WalkerOS.PushOptions | NodeDestination.Config;\n\nexport interface PushResult extends NodeDestination.PushResult {\n  command?: Command;\n  event?: WalkerOS.Event;\n  status: Status;\n}\n\nexport interface SetupResult extends NodeDestination.SetupResult {\n  status: Status;\n}\n\nexport interface Command {\n  name: string;\n  data: unknown;\n}\n\nexport interface Status {\n  ok: boolean;\n  error?: string;\n}\n\nexport type PartialConfig = Partial<Config>;\nexport interface Config extends WalkerOS.Config {\n  client: string;\n  destinations: Destinations;\n  globalsStatic: WalkerOS.Properties;\n  queue: WalkerOS.Events;\n  contracts?: Schema.Contracts;\n  source: WalkerOS.Source;\n  onError?: Handler.Error;\n  onLog?: Handler.Log;\n}\n\nexport interface Destinations {\n  [key: string]: NodeDestination.Function;\n}\n\nexport type PrependInstance<Fn extends (...args: any) => any> = (\n  instance: Function,\n  ...args: Parameters<Fn>\n) => ReturnType<Fn>;\n","import type { Destination, WalkerOS } from '@elbwalker/types';\n\nexport interface Function<Custom = unknown, EventCustom = unknown>\n  extends Destination.Function<Custom, EventCustom> {\n  push: PushFn<Custom, EventCustom>;\n  init?: InitFn<Custom, EventCustom>;\n  setup?: SetupFn<Custom, EventCustom>;\n}\n\nexport type PushFn<Custom, EventCustom> = (\n  events: PushEvents<EventCustom>,\n  config: Config<Custom, EventCustom>,\n) => Promise<Push> | void;\n\nexport type InitFn<Custom, EventCustom> = (\n  config: Config<Custom, EventCustom>,\n) => Promise<boolean | Config<Custom, EventCustom>>;\n\nexport type SetupFn<Custom, EventCustom> = (\n  config: Config<Custom, EventCustom>,\n) => Promise<boolean | Config<Custom, EventCustom>>;\n\nexport interface Config<Custom = unknown, EventCustom = unknown>\n  extends Destination.Config<Custom, EventCustom> {}\n\nexport interface Mapping<EventCustom>\n  extends Destination.Mapping<EventCustom> {}\n\nexport interface EventConfig<EventCustom = unknown>\n  extends Destination.EventConfig<EventCustom> {}\n\nexport type PushEvents<EventCustom = unknown> = Array<PushEvent<EventCustom>>;\n\nexport type PushEvent<EventCustom = unknown> = {\n  event: WalkerOS.Event;\n  mapping?: EventConfig<EventCustom>;\n};\n\nexport type Ref = {\n  id: string;\n  destination: Function;\n};\n\nexport type Push = {\n  queue?: WalkerOS.Events;\n  error?: unknown;\n};\n\nexport type PushSuccess = Array<Ref>;\n\nexport type PushFailure = Array<Ref & { error: PushError }>;\n\nexport type PushError = string;\n\nexport type PushResult = {\n  successful: PushSuccess;\n  queued: PushSuccess;\n  failed: PushFailure;\n};\n\nexport type SetupResult = {\n  successful: PushSuccess;\n  failed: PushFailure;\n};\n"],"mappings":"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","names":["Commands","UtilsStorage","Utils","Const","assign","target","source","key","sourceProp","targetProp","acc","item","getId","length","str","l","isSameType","variable","type","onLog","message","verbose","tryCatchAsync","fn","onError","args","err","destination","event","error"]}