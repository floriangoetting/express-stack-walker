import { Destination, WalkerOS, Schema, Handler } from '@elbwalker/types';

interface Function$1<Custom = unknown, EventCustom = unknown> extends Destination.Function<Custom, EventCustom> {
    push: PushFn<Custom, EventCustom>;
    init?: InitFn<Custom, EventCustom>;
    setup?: SetupFn<Custom, EventCustom>;
}
type PushFn<Custom, EventCustom> = (events: PushEvents<EventCustom>, config: Config$1<Custom, EventCustom>) => Promise<Push$1> | void;
type InitFn<Custom, EventCustom> = (config: Config$1<Custom, EventCustom>) => Promise<boolean | Config$1<Custom, EventCustom>>;
type SetupFn<Custom, EventCustom> = (config: Config$1<Custom, EventCustom>) => Promise<boolean | Config$1<Custom, EventCustom>>;
interface Config$1<Custom = unknown, EventCustom = unknown> extends Destination.Config<Custom, EventCustom> {
}
interface Mapping<EventCustom> extends Destination.Mapping<EventCustom> {
}
interface EventConfig<EventCustom = unknown> extends Destination.EventConfig<EventCustom> {
}
type PushEvents<EventCustom = unknown> = Array<PushEvent<EventCustom>>;
type PushEvent<EventCustom = unknown> = {
    event: WalkerOS.Event;
    mapping?: EventConfig<EventCustom>;
};
type Ref = {
    id: string;
    destination: Function$1;
};
type Push$1 = {
    queue?: WalkerOS.Events;
    error?: unknown;
};
type PushSuccess = Array<Ref>;
type PushFailure = Array<Ref & {
    error: PushError;
}>;
type PushError = string;
type PushResult$1 = {
    successful: PushSuccess;
    queued: PushSuccess;
    failed: PushFailure;
};
type SetupResult$1 = {
    successful: PushSuccess;
    failed: PushFailure;
};

type destination_EventConfig<EventCustom = unknown> = EventConfig<EventCustom>;
type destination_InitFn<Custom, EventCustom> = InitFn<Custom, EventCustom>;
type destination_Mapping<EventCustom> = Mapping<EventCustom>;
type destination_PushError = PushError;
type destination_PushEvent<EventCustom = unknown> = PushEvent<EventCustom>;
type destination_PushEvents<EventCustom = unknown> = PushEvents<EventCustom>;
type destination_PushFailure = PushFailure;
type destination_PushFn<Custom, EventCustom> = PushFn<Custom, EventCustom>;
type destination_PushSuccess = PushSuccess;
type destination_Ref = Ref;
type destination_SetupFn<Custom, EventCustom> = SetupFn<Custom, EventCustom>;
declare namespace destination {
  export {
    Config$1 as Config,
    destination_EventConfig as EventConfig,
    Function$1 as Function,
    destination_InitFn as InitFn,
    destination_Mapping as Mapping,
    Push$1 as Push,
    destination_PushError as PushError,
    destination_PushEvent as PushEvent,
    destination_PushEvents as PushEvents,
    destination_PushFailure as PushFailure,
    destination_PushFn as PushFn,
    PushResult$1 as PushResult,
    destination_PushSuccess as PushSuccess,
    destination_Ref as Ref,
    destination_SetupFn as SetupFn,
    SetupResult$1 as SetupResult,
  };
}

interface Function {
    config: Config;
    push: Push;
    setup?: Setup;
}
interface AddDestination {
    (id: string, destination: Function$1<any, any>): void;
}
interface Push {
    (nameOrEvent: string | WalkerOS.PartialEvent, data?: PushData, options?: PushOptions): Promise<PushResult>;
}
interface Setup {
    (config: Config): Promise<SetupResult>;
}
type PushData = WalkerOS.PushData | Function$1<any, any> | PushResult$1;
type PushOptions = WalkerOS.PushOptions | Config$1;
interface PushResult extends PushResult$1 {
    command?: Command;
    event?: WalkerOS.Event;
    status: Status;
}
interface SetupResult extends SetupResult$1 {
    status: Status;
}
interface Command {
    name: string;
    data: unknown;
}
interface Status {
    ok: boolean;
    error?: string;
}
type PartialConfig = Partial<Config>;
interface Config extends WalkerOS.Config {
    client: string;
    destinations: Destinations;
    globalsStatic: WalkerOS.Properties;
    queue: WalkerOS.Events;
    contracts?: Schema.Contracts;
    source: WalkerOS.Source;
    onError?: Handler.Error;
    onLog?: Handler.Log;
}
interface Destinations {
    [key: string]: Function$1;
}
type PrependInstance<Fn extends (...args: any) => any> = (instance: Function, ...args: Parameters<Fn>) => ReturnType<Fn>;

type client_AddDestination = AddDestination;
type client_Command = Command;
type client_Config = Config;
type client_Destinations = Destinations;
type client_Function = Function;
type client_PartialConfig = PartialConfig;
type client_PrependInstance<Fn extends (...args: any) => any> = PrependInstance<Fn>;
type client_Push = Push;
type client_PushData = PushData;
type client_PushOptions = PushOptions;
type client_PushResult = PushResult;
type client_Setup = Setup;
type client_SetupResult = SetupResult;
type client_Status = Status;
declare namespace client {
  export {
    client_AddDestination as AddDestination,
    client_Command as Command,
    client_Config as Config,
    client_Destinations as Destinations,
    client_Function as Function,
    client_PartialConfig as PartialConfig,
    client_PrependInstance as PrependInstance,
    client_Push as Push,
    client_PushData as PushData,
    client_PushOptions as PushOptions,
    client_PushResult as PushResult,
    client_Setup as Setup,
    client_SetupResult as SetupResult,
    client_Status as Status,
  };
}

declare function createNodeClient(customConfig?: PartialConfig): {
    elb: Push;
    instance: Function;
};
declare function nodeClient(customConfig?: PartialConfig): Function;

export { client as NodeClient, destination as NodeDestination, createNodeClient, createNodeClient as default, nodeClient };
